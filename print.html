<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Embedded WebAssembly (WASM)</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01-intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="02-getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="03-contributing.html"><strong aria-hidden="true">3.</strong> Contributing</a></li><li class="chapter-item expanded "><a href="04-spec.html"><strong aria-hidden="true">4.</strong> Specification</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Low Level APIs</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="spec/i2c.html"><strong aria-hidden="true">4.1.1.</strong> I2C</a></li><li class="chapter-item expanded "><a href="spec/spi.html"><strong aria-hidden="true">4.1.2.</strong> SPI</a></li><li class="chapter-item expanded "><a href="spec/uart.html"><strong aria-hidden="true">4.1.3.</strong> UART</a></li><li class="chapter-item expanded "><a href="spec/gpio.html"><strong aria-hidden="true">4.1.4.</strong> GPIO</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> High Level APIs</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="spec/led.html"><strong aria-hidden="true">4.2.1.</strong> LED</a></li><li class="chapter-item expanded "><a href="spec/display.html"><strong aria-hidden="true">4.2.2.</strong> Display</a></li><li class="chapter-item expanded "><a href="spec/pub_sub.html"><strong aria-hidden="true">4.2.3.</strong> Pub/Sub</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="05-hals.html"><strong aria-hidden="true">5.</strong> HALs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hals/rust.html"><strong aria-hidden="true">5.1.</strong> Rust</a></li><li class="chapter-item expanded "><a href="hals/assemblyscript.html"><strong aria-hidden="true">5.2.</strong> AssemblyScript</a></li></ol></li><li class="chapter-item expanded "><a href="06-runtimes.html"><strong aria-hidden="true">6.</strong> Runtimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="runtimes/wasm3.html"><strong aria-hidden="true">6.1.</strong> Wasm3</a></li><li class="chapter-item expanded "><a href="runtimes/wasmtime.html"><strong aria-hidden="true">6.2.</strong> Wasmtime</a></li></ol></li><li class="chapter-item expanded "><a href="08-management-api.html"><strong aria-hidden="true">7.</strong> Management APIs</a></li><li class="chapter-item expanded "><a href="09-tools.html"><strong aria-hidden="true">8.</strong> Tools</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Embedded WebAssembly (WASM)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This project defines WASI APIs for embedded devices with the aim of providing common language and platform independent runtimes for embedded use, allowing applications to be abstract from platforms, supporting dynamic discovery and hot reloading of applications, and making it easy to design / share / mess with embedded things.</p>
<p>The WASI APIs are intended to span from basic peripheral drivers like SPI and I2C, to more complex functionality like driving LEDs or displays and publishing or subscribing to data. Everything one could need to write unreasonably portable embedded applications.</p>
<p>The project provides an API specification with runtimes to support the execution of this and Hardware Abstraction Layers (HALs) for application development. To get started using embedded-wasm, grab the relevant components and/or check out the <a href="./02-getting-started">Getting Started</a> section.</p>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<h2 id="specification"><a class="header" href="#specification"><a href="https://github.com/embedded-wasm/spec">Specification</a></a></h2>
<p>The <a href="https://github.com/embedded-wasm/spec">embedded-wasm/spec</a> project provides the <code>witx</code> API specification as well as helper abstractions for platform implementations and standard tests for HAL/runtime interoperability.</p>
<p><a href="https://crates.io/crates/wasm-embedded-spec"><img src="https://img.shields.io/crates/v/wasm-embedded-spec.svg" alt="Crates.io" /></a>
<a href="https://docs.rs/wasm-embedded-spec"><img src="https://docs.rs/wasm-embedded-spec/badge.svg" alt="Docs.rs" /></a></p>
<h3 id="runtimes"><a class="header" href="#runtimes">Runtimes</a></h3>
<h4 id="wasm-embedded-rt"><a class="header" href="#wasm-embedded-rt"><a href="https://github.com/embedded-wasm/rt">wasm-embedded-rt</a></a></h4>
<p>An embedded-wasm runtime for execution on linux / macOS / windows, wrapping specific runtime implementations to provide a ready-to-go binary. This supports mocking on all platforms, with physical hardware access only on linux (for now?).</p>
<p><a href="https://crates.io/crates/wasm-embedded-rt"><img src="https://img.shields.io/crates/v/wasm-embedded-rt.svg" alt="Crates.io" /></a>
<a href="https://docs.rs/wasm-embedded-rt"><img src="https://docs.rs/wasm-embedded-rt/badge.svg" alt="Docs.rs" /></a></p>
<p>You can install this with <code>cargo install wasm-embedded-rt</code> or grab a binary from the <a href="https://github.com/embedded-wasm/rt/releases/latest">releases</a> page.</p>
<h4 id="wasm-embedded-rt-wasmtime"><a class="header" href="#wasm-embedded-rt-wasmtime"><a href="https://github.com/embedded-wasm/rt_wasmtime">wasm-embedded-rt-wasmtime</a></a></h4>
<p>A Rust/wasmtime based runtime for application use, built into <code>wasm-embedded-rt</code> with the <code>rt_wasmtime</code> feature.</p>
<p><a href="https://crates.io/crates/wasm-embedded-rt-wasmtime"><img src="https://img.shields.io/crates/v/wasm-embedded-rt-wasmtime.svg" alt="Crates.io" /></a>
<a href="https://docs.rs/wasm-embedded-rt-wasmtime"><img src="https://docs.rs/wasm-embedded-rt-wasmtime/badge.svg" alt="Docs.rs" /></a></p>
<p>Typically you'll want to embed this library in your project, either as a git submodule or by copying out the <code>lib</code> directory.</p>
<h4 id="wasm-embedded-rt-wasm3"><a class="header" href="#wasm-embedded-rt-wasm3"><a href="https://github.com/embedded-wasm/rt_wasm3">wasm-embedded-rt-wasm3</a></a></h4>
<p>A C/wasm3 based runtime designed for embedding, built into <code>wasm-embedded-rt-wasm3</code> with the <code>rt_wasm3</code> feature.</p>
<p><a href="https://crates.io/crates/wasm-embedded-rt-wasm3"><img src="https://img.shields.io/crates/v/wasm-embedded-rt-wasm3.svg" alt="Crates.io" /></a>
<a href="https://docs.rs/wasm-embedded-rt-wasm3"><img src="https://docs.rs/wasm-embedded-rt-wasm3/badge.svg" alt="Docs.rs" /></a></p>
<p>Typically you'll want to embed this library in your project, either as a cargo dependency, git submodule or by copying out the <code>lib</code> directory.</p>
<h3 id="hardware-abstraction-layers-hals"><a class="header" href="#hardware-abstraction-layers-hals">Hardware Abstraction Layers (HALs)</a></h3>
<h4 id="rust"><a class="header" href="#rust">Rust</a></h4>
<p>Rust bindings based on <a href="https://github.com/rust-embedded/embedded-hal">embedded-hal</a>.</p>
<p><a href="https://crates.io/crates/wasm-embedded-hal"><img src="https://img.shields.io/crates/v/wasm-embedded-hal.svg" alt="Crates.io" /></a>
<a href="https://docs.rs/wasm-embedded-hal"><img src="https://docs.rs/wasm-embedded-hal/badge.svg" alt="Docs.rs" /></a></p>
<p>Add this to your project with <code>cargo add wasm-embedded-hal</code>.</p>
<h4 id="assemblyscript"><a class="header" href="#assemblyscript">AssemblyScript</a></h4>
<p>Bindings for <a href="https://www.assemblyscript.org">AssemblyScript</a>, compiled with <code>asc</code>.</p>
<p><a href="https://npmjs.com/package/wasm-embedded-hal"><img src="https://img.shields.io/npm/v/wasm-embedded-hal" alt="npm" /></a></p>
<p>Add this to your project with <code>npm install --save wasm-embedded-hal</code>.</p>
<h3 id="tools"><a class="header" href="#tools">Tools</a></h3>
<h4 id="wasm-embedded-cli"><a class="header" href="#wasm-embedded-cli"><a href="">wasm-embedded-cli</a></a></h4>
<p>WIP: A command line interface for interacting with embedded-wasm capable devices.</p>
<p><a href="https://crates.io/crates/wasm-embedded-cli"><img src="https://img.shields.io/crates/v/wasm-embedded-cli.svg" alt="Crates.io" /></a>
<a href="https://docs.rs/wasm-embedded-cli"><img src="https://docs.rs/wasm-embedded-cli/badge.svg" alt="Docs.rs" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>To get started using <code>embedded-wasm</code> you need to find a suitable runtime for your platform, and the appropriate Hardware Abstraction Layer (HAL) to write applications in your language of choice. 
If your language or platform isn't supported, check out the <a href="./06-porting.html">porting</a> documentation, and for more information on building/testing <code>embedded-wasm</code> components, see <a href="./03-contributing.html">contributing</a></p>
<p>For the purposes of this guide, we're going to use the <code>wasm-embedded-rt</code> the linux runtime on a Raspberry Pi, as it's a common platform with useful physical interfaces, and the rust HAL. 
You're going to need <a href="https://rustup.rs">rust</a> installed, and may find it useful to set <code>$PROJECT</code> as an environmental variable while following along.</p>
<p><em>Please note this is very much a work in progress, expect some hickups / bugs / sharp edges that are yet-to-be resolved</em></p>
<h3 id="installing-the-runtime"><a class="header" href="#installing-the-runtime">Installing the runtime</a></h3>
<p>First we need to install the runtime. The most straightfoward approach is to fetch a precompiled binary from the <a href="https://github.com/embedded-wasm/rt/releases/latest">releases</a> page.</p>
<p>For aarch64 (64-bit):</p>
<pre><code>wget https://github.com/embedded-wasm/rt/releases/download/v0.1.2/wasm-embedded-rt-aarch64-unknown-linux-gnu.tgz
tar -xvf wasm-embedded-rt-aarch64-unknown-linux-gnu.tgz
sudo cp wasm-embedded-rt /usr/local/bin
</code></pre>
<p>For armv7 (32-bit), note this only supports the <code>wasm3</code> engine:</p>
<pre><code>wget https://github.com/embedded-wasm/rt/releases/download/latest/wasm-embedded-rt-armv7-unknown-linux-gnueabihf.tgz
tar -xvf wasm-embedded-rt-armv7-unknown-linux-gnueabihf.tgz
sudo cp wasm-embedded-rt /usr/local/bin
</code></pre>
<p>Alternately you can use: </p>
<ul>
<li><code>cargo binstall wasm-embedded-rt</code> to install the precompiled binary via <a href="https://github.com/ryankurte/cargo-binstall"><code>cargo-binstall</code></a></li>
<li><code>cargo install wasm-embedded-rt</code> to build from source (note you may need to set <a href="https://github.com/embedded-wasm/rt/blob/main/.github/workflows/ci.yml#L21">features</a> appropriate to your platform)</li>
</ul>
<p>Once you have this installed you should be able to invoke <code>wasm-embedded-rt</code>:</p>
<pre><code>&gt; wasm-embedded-rt --help
wasm-embedded-rt 0.1.2

USAGE:
    wasm-embedded-rt [OPTIONS] &lt;bin&gt;

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
        --config &lt;config&gt;          Configuration file (toml)
        --log-level &lt;log-level&gt;    Configure app logging levels (warn, info, debug, trace) [default: info]
        --mode &lt;mode&gt;              Operating mode [default: dynamic]
        --runtime &lt;runtime&gt;        Runtime [default: wasmtime]

ARGS:
    &lt;bin&gt;    WASM binary to execute
</code></pre>
<h3 id="building-an-application"><a class="header" href="#building-an-application">Building an application</a></h3>
<p>To get started with the rust HAL you will need to setup a new cargo binary project (where <code>$PROJECT</code> is your project name). You can do this on the Raspberry Pi, or another machine (though you will need to copy binaries to the RPi).</p>
<ol>
<li><code>cargo new --bin $PROJECT &amp;&amp; cd $PROJECT</code> to create the project and change to the new directory</li>
<li><code>rustup target add wasm32-wasi</code> to add the <code>wasm32-wasi</code> target</li>
<li><code>mkdir .cargo &amp;&amp; echo '[build]\r\ntarget = &quot;wasm32-wasi&quot;' &gt; .cargo/config</code> to set the default build target</li>
</ol>
<ul>
<li>note this can also be set using <code>forced-target = &quot;wasm32-wasi&quot;</code> in <code>Cargo.toml</code></li>
</ul>
<ol start="4">
<li><code>cargo add wasm-embedded-hal</code> to add the <code>wasm-embedded-hal</code> dependency (via <a href="https://github.com/killercup/cargo-edit/"><code>cargo-edit</code></a>)</li>
<li><code>cargo build</code> to build the application</li>
</ol>
<p>Once you've setup your project you can use the provided APIs to talk to physical peripherals, add the following to your <code>src/main.rs</code> and build with <code>cargo build</code>.</p>
<pre><pre class="playground"><code class="language-rust">//! An I2C detect example using wasm-embedded-hal
//!
// Copyright 2020 Ryan Kurte

use embedded_hal::i2c::blocking::*;
use wasm_embedded_hal::i2c::I2c;

/// Default I2C bus to poll (must be enabled via `raspi-config`)
const BUS: u32 = 1;

fn main() {
    // Connect to I2C device
    let mut i2c = match I2c::init(BUS, 0, -1, -1) {
        Ok(v) =&gt; v,
        Err(_e) =&gt; return,
    };

    println!(&quot;Scanning addresses on bus: {}&quot;, BUS);

    // For each possible address
    for i in 0..128 {
        // Print the address every line
        if i % 16 == 0 {
            print!(&quot;0x{:02x}: &quot;, i);
        }

        // Attempt a read
        let mut d = [0u8; 1];
        match i2c.read(i, &amp;mut d) {
            Ok(_) =&gt; print!(&quot;{:02x} &quot;, d),
            Err(_) =&gt; print!(&quot;-- &quot;),
        }

        // Line break every 16 addresses
        if i % 16 == 15 {
            print!(&quot;\r\n&quot;);
        }
    }

    // Shutdown the I2C device
    i2c.deinit();

    return;
}
</code></pre></pre>
<p>For more examples check out <a href="https://github.com/embedded-wasm/hal_rs/tree/main/examples"><code>hal_rs/examples</code></a>.</p>
<h3 id="running-your-application"><a class="header" href="#running-your-application">Running your application</a></h3>
<p>If you're working remotely, copy your new binary to the RPi with <code>scp target/debug/$PROJECT.wasm pi@raspberrypi</code> (replacing <code>raspberrypi</code> with a different hostname if required).</p>
<p>You can then run your new application on the RPi:</p>
<pre><code>&gt; wasm-embedded-rt --mode linux --log-level error --runtime wasm3 $PROJECT.wasm
Loading WebAssembly (mod: wasme, p: 0x7fb90bb010, 1950651 bytes)...
Initialising I2C device: 1
Received I2C handle: 0
Scanning addresses on bus: 1
0x00: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
0x10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
0x20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
0x30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
0x40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
0x50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
0x60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
0x70: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
</code></pre>
<p><em>Note we're using <code>--runtime wasm3</code> here due to a bug in the <code>wasmtime</code> runtime error codes, this will be removed when resolved</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>First make sure you've got the tools installed per <a href="./02-getting-started.html">Getting Started</a>.</p>
<p>Heads up that there are a lot of moving parts, and it's definitely not a <em>simple</em> process (sorry!). We hope that in future more of this will be generated / automated, but we're waiting for the <a href="https://github.com/WebAssembly/WASI/blob/main/docs/witx.md">WITX</a> specification to stabilise before this is likely. If you have any ideas for simplifying the process please do let us know!</p>
<p><strong>Please note these instructions were moved from a prior monorepo version of this project, the <em>concept</em> is the same but the links and components are yet to be updated. You can see the original docs <a href="https://ryan.kurte.nz/embedded-wasm">here</a></strong></p>
<h2 id="updating-the-docs"><a class="header" href="#updating-the-docs">Updating the docs</a></h2>
<p>The <a href="https://github.com/embedded-wasm/book">embedded-wasm/book</a> project contains these docs, please feel free to open a PR!</p>
<h2 id="proposing-an-api"><a class="header" href="#proposing-an-api">Proposing an API</a></h2>
<p>So you recon we're missing a useful API? (you're probably right). Before going down the implementation path you may wish to open an <a href="https://github.com/embedded-wasm/spec/issues/new">issue</a> for discussion.</p>
<p>Once you're ready to implement, there are a few steps to the process. You'll need to be familiar with building rust and C projects, and you'll need to setup a workspace to coordinate these changes between components. If you run into any roadblocks, again, please open an issue or PR!</p>
<h2 id="setting-up-your-workspace"><a class="header" href="#setting-up-your-workspace">Setting up your workspace</a></h2>
<p>First you'll need to setup a workspace containing the subprojects, we suggest using <a href="./assets/bootstrap.sh"><code>bootstrap.sh</code></a>.</p>
<h3 id="updating-the-specification"><a class="header" href="#updating-the-specification">Updating the <a href="https://github.com/embedded-wasm/spec">specification</a></a></h3>
<ul>
<li>Add a <a href="">witx</a> specification for the protocol to the <code>witx</code> folder (see <a href="https://github.com/embedded-wasm/spec/blob/main/witx/spi.witx">witx/spi.witx</a> for an example)</li>
<li>Update the list of specs in <code>lib/api.rs</code> to tell <code>wiggle</code> where to find the document</li>
<li>Add rust platform API to <code>src/</code> (see <a href="https://github.com/embedded-wasm/spec/blob/main/src/spi.rs">src/spi.rs</a> for an example)</li>
<li>Add C platform API to <code>lib/</code> (see <a href="https://github.com/embedded-wasm/spec/blob/main/inc/wasm_embedded/spi.h">inc/wasm_embedded/spi.h</a> for an example)</li>
<li>Add a test definition to <code>tests/</code> for qualification of runtimes / HALs</li>
<li>Check with <code>cargo check --all-features</code></li>
</ul>
<h3 id="updating-the-runtimes"><a class="header" href="#updating-the-runtimes">Updating the runtimes</a></h3>
<p>You will first need to implement your API for the each of the underlying <code>rt-wasm3</code> or <code>rt-wasmtime</code> engines, then in <code>wasm-embedded-rt</code>.</p>
<h4 id="updating-rt-wasmtime"><a class="header" href="#updating-rt-wasmtime">Updating rt-wasmtime</a></h4>
<p>TODO: not yet split from <code>rt</code>.</p>
<h4 id="updating-rt-wasm3"><a class="header" href="#updating-rt-wasm3">Updating rt-wasm3</a></h4>
<p>The <code>rt-wasm3</code> C library is designed to simplify porting and embedding. A simple Object Oriented C / VTable style object is defined in the spec for each API, hiding the runtime implementation from the user and supporting dependency injection and other useful testing tricks.</p>
<p>To add an API:</p>
<ul>
<li>Create new source and header files for your API</li>
<li>Add the new source file to <a href="https://github.com/embedded-wasm/rt_wasm3/tree/main/lib/CMakeLists.txt">CMakeLists.txt</a> to add it to the build</li>
<li>Add the new header file to <a href="https://github.com/embedded-wasm/rt_wasm3/blob/main/lib/build.rs">build.rs</a> with appropriate allow-listing to support rust binding generation
<ul>
<li>Ensure you block generation of driver types from the <code>spec</code> package (eg, <code>spi_drv_t</code>) to avoid generating conflicting incompatible symbols</li>
</ul>
</li>
<li>Create C function declarations for the new methods and a container object (vtable-esque) to hold these</li>
<li>Add m3 calls for each new method, deferring to the container object</li>
<li>Add a helper function to bind an instance of this API to the wasme runtime (see <code>WASME_bind_i2c</code>).</li>
<li>Add C bindings to the rust runtime, see <a href="https://github.com/ryankurte/embedded-wasm/tree/main/rt/src/wasm3">rt/src/wasm3/</a> for examples.</li>
</ul>
<p>Explaining all of this is more difficult than showing so, see <a href="https://github.com/ryankurte/embedded-wasm/tree/main/lib/src/i2c.c">lib/src/i2c.c</a> and <a href="https://github.com/ryankurte/embedded-wasm/tree/main/lib/inc/wasme/i2c.h">lib/inc/wasme/i2c.h</a> for an example.</p>
<p>When working with the library you can build with <code>make lib</code>, or use the classic CMake approach from <code>lib/</code> of:</p>
<ul>
<li><code>mkdir build &amp;&amp; cd build</code> to create and switch to a build directory</li>
<li><code>cmake ..</code> to setup the project</li>
<li><code>make</code> to perform a build</li>
</ul>
<p>When the runtime is built with <code>--features=wasm3</code> the <code>ewasm</code> library will also be included. You can use this instead however, the logs exposed when building under cargo leave a lot to be desired.</p>
<h4 id="updating-rt"><a class="header" href="#updating-rt">Updating <code>rt</code></a></h4>
<ul>
<li>Add a mock implementation to <code>src/mock/</code> for mock execution, see <a href="https://github.com/embedded-wasm/rt/tree/main/src/mock/i2c.rs">src/mock/i2c.rs</a> for an example</li>
<li>Add a linux implementation to <code>src/linux/</code> for runtime use, see <a href="https://github.com/embedded-wasm/rt/tree/main/src/linux/i2c.rs">src/linux/i2c.rs</a> for an example</li>
</ul>
<h3 id="updating-the-hal-rust"><a class="header" href="#updating-the-hal-rust">Updating the HAL (rust)</a></h3>
<p>This HAL exposes the API to rust users, providing an implementation of <a href="https://github.com/rust-embedded/embedded-hal">embedded-hal</a>.</p>
<ul>
<li>Create a new source file in <a href="">hal_rs/src/</a> for the new API</li>
<li>Create an API module with <code>extern</code> definitions for the WASI interface</li>
<li>Create a wrapper type for the API object, using the handle and <code>extern</code> functions, see <a href="https://github.com/embedded-wasm/hal_rs/blob/main/src/i2c.rs">hal_rs/src/i2c.rs</a> for an example</li>
<li>Update the tests list in <code>.github/workflows/ci.yml</code></li>
</ul>
<h3 id="updating-the-hal-assemblyscript"><a class="header" href="#updating-the-hal-assemblyscript">Updating the HAL (AssemblyScript)</a></h3>
<p>This HAL exposes the API to AssemblyScript users. </p>
<ul>
<li>Create a new source file in <a href="">hal_rs/src/</a> for the new API</li>
<li>Create an API module with <code>extern</code> definitions for the WASI interface</li>
<li>Create a wrapper type for the API object, using the handle and <code>extern</code> functions, see <a href="https://github.com/embedded-wasm/hal_rs/blob/main/src/i2c.rs">hal_rs/src/i2c.rs</a> for an example</li>
<li>Update the tests list in <code>.github/workflows/ci.yml</code></li>
</ul>
<h3 id="testing-your-changes"><a class="header" href="#testing-your-changes">Testing your changes</a></h3>
<p>TODO</p>
<h2 id="hints"><a class="header" href="#hints">Hints</a></h2>
<ul>
<li>All APIs use integer handles for each device/peripheral managed by the platform to avoid the need to pass opaque objects
<ul>
<li>On initialisation a positive handle should be returned, on error a negative code</li>
<li>These handles are managed by the runtime and should be closed or will be cleaned-up on exit</li>
</ul>
</li>
<li>Remember that the WASM runtime has it's own address space
<ul>
<li>Function calls with objects will resolve to an integer address that must be translated before access</li>
<li>If an object contains a pointer you will also need to translate this prior to accessing containing data</li>
</ul>
</li>
<li>The WASM call ABI is not yet stable / widely supported
<ul>
<li>WITX allows multiple returns, in practice this <em>may</em> resolve to an extra argument in the function call (eg. <code>fn do(a) -&gt; Result&lt;b, c&gt;</code> becomes <code>fn do(a, &amp;mut b) -&gt; c</code> in WASM)</li>
</ul>
</li>
<li>A <a href="https://github.com/bytecodealliance/wasmtime/issues/3519">bug</a> with <code>wiggle</code> means <code>witx</code> path resolution breaks when using workspaces, resulting in an <code>error: proc macro panicked</code> and a bunch of <code>error[E0432]: unresolved import</code>s. Patch <code>wasm-embedded-spec</code> using a folder outside the workspace or a git version until this is resolved</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apis"><a class="header" href="#apis">APIs</a></h1>
<p>This project provides a set of platform APIs to support embedded applications, designed to be platform, language, and runtime, independent. APIs are designed to be simple, avoiding the transfer of complex objects over the WASM boundary and leaving the construction and management of objects to the runtime and library. </p>
<p>Runtime abstractions and libraries mean that most users should not need to interact with these directly so, unless you're planning to implement a runtime or library you may choose to skip this section.</p>
<p>For more information (and the actual specifications), see <a href="https://github.com/embedded-wasm/spec">embedded-wasm/spec</a>.</p>
<h3 id="low-level-apis"><a class="header" href="#low-level-apis">Low Level APIs</a></h3>
<ul>
<li><a href="./spec/i2c.html">I2C</a></li>
<li><a href="./spec/spi.html">SPI</a></li>
<li><a href="./spec/uart.html">UART</a></li>
<li><a href="./spec/gpio.html">GPIO</a></li>
</ul>
<h3 id="high-level-apis"><a class="header" href="#high-level-apis">High Level APIs</a></h3>
<ul>
<li><a href="./spec/led.html">LED</a></li>
<li><a href="./spec/display.html">Display</a></li>
<li><a href="./spec/pub_sub.html">Pub/Sub</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i2c-api"><a class="header" href="#i2c-api">I2C API</a></h1>
<h2 id="specification-1"><a class="header" href="#specification-1">Specification</a></h2>
<p>The I2C API specification is defined in <a href="https://github.com/embedded-wasm/spec/blob/main/witx/i2c.witx">spec/i2c.witx</a>:</p>
<p>TODO: demonstrate here</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spi-api"><a class="header" href="#spi-api">SPI API</a></h1>
<h2 id="specification-2"><a class="header" href="#specification-2">Specification</a></h2>
<p>The SPI API specification is defined in <a href="https://github.com/embedded-wasm/spec/blob/main/witx/spi.witx">spec/spi.witx</a>:</p>
<p>TODO: describe / demonstrate here</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uart"><a class="header" href="#uart">UART</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gpio"><a class="header" href="#gpio">GPIO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="led"><a class="header" href="#led">LED</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="display"><a class="header" href="#display">Display</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pubsub"><a class="header" href="#pubsub">Pub/Sub</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hals"><a class="header" href="#hals">HALs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>TODO: document + link to https://github.com/embedded-wasm/hal_rs</p>
<div style="break-before: page; page-break-before: always;"></div><p>TODO: document + link to https://github.com/embedded-wasm/hal_as</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime"><a class="header" href="#runtime">Runtime</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm3"><a class="header" href="#wasm3">Wasm3</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmtime"><a class="header" href="#wasmtime">Wasmtime</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="management-apis"><a class="header" href="#management-apis">Management APIs</a></h1>
<p>A set of management APIs are defined to support consistent interaction with wasm-embedded capable devices.</p>
<h2 id="discovery"><a class="header" href="#discovery">Discovery</a></h2>
<p>Network devices SHOULD support discovery via <a href="">mDNS</a> with the service type <code>_ewasm</code>.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>Configuration values </p>
<h2 id="execution"><a class="header" href="#execution">Execution</a></h2>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<p>Logging is based on the <a href="https://datatracker.ietf.org/doc/html/rfc5424">syslog protocol</a> with either a <a href="https://datatracker.ietf.org/doc/html/rfc5426">UDP</a> or WebSocket connection.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tools-1"><a class="header" href="#tools-1">Tools</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
